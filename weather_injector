"""
Real-time Weather Data Injection for Grid Simulation
"""
import requests
import numpy as np
import pandas as pd
from datetime import datetime, timedelta
from typing import Dict, List, Tuple
import yaml
import os
from dotenv import load_dotenv

load_dotenv()


class WeatherInjector:
    """Fetches and processes weather data for renewable energy modeling"""

    def __init__(self, config_path: str = "config.yaml"):
        with open(config_path, 'r') as f:
            self.config = yaml.safe_load(f)

        self.api_key = os.getenv('OPENWEATHER_API_KEY') or self.config['weather']['api_key']
        self.lat = self.config['weather']['location']['lat']
        self.lon = self.config['weather']['location']['lon']
        self.forecast_hours = self.config['weather']['forecast_hours']

    def fetch_forecast(self) -> pd.DataFrame:
        """Fetch weather forecast from OpenWeatherMap API"""
        url = f"https://api.openweathermap.org/data/2.5/forecast"
        params = {
            'lat': self.lat,
            'lon': self.lon,
            'appid': self.api_key,
            'units': 'metric',
            'cnt': self.forecast_hours  # 3-hour intervals
        }

        try:
            response = requests.get(url, params=params, timeout=10)
            response.raise_for_status()
            data = response.json()

            weather_data = []
            for item in data['list']:
                weather_data.append({
                    'timestamp': datetime.fromtimestamp(item['dt']),
                    'temperature': item['main']['temp'],
                    'wind_speed': item['wind']['speed'],
                    'wind_direction': item['wind'].get('deg', 0),
                    'cloud_cover': item['clouds']['all'] / 100.0,
                    'humidity': item['main']['humidity'] / 100.0,
                    'pressure': item['main']['pressure']
                })

            return pd.DataFrame(weather_data)

        except Exception as e:
            print(f"Weather API error: {e}")
            return self._generate_synthetic_weather()

    def _generate_synthetic_weather(self) -> pd.DataFrame:
        """Generate synthetic weather data for testing without API"""
        timestamps = pd.date_range(
            start=datetime.now(),
            periods=self.forecast_hours,
            freq='3H'
        )

        np.random.seed(42)
        weather_data = {
            'timestamp': timestamps,
            'temperature': 20 + 10 * np.sin(np.linspace(0, 2*np.pi, len(timestamps))) + np.random.randn(len(timestamps)) * 2,
            'wind_speed': np.maximum(0, 8 + np.random.randn(len(timestamps)) * 3),
            'wind_direction': np.random.uniform(0, 360, len(timestamps)),
            'cloud_cover': np.clip(0.3 + np.random.randn(len(timestamps)) * 0.2, 0, 1),
            'humidity': np.clip(0.6 + np.random.randn(len(timestamps)) * 0.1, 0, 1),
            'pressure': 1013 + np.random.randn(len(timestamps)) * 5
        }

        return pd.DataFrame(weather_data)

    def weather_to_solar_output(self, weather_df: pd.DataFrame) -> np.ndarray:
        """Convert weather data to solar PV output (p.u.)"""
        cfg = self.config['renewables']['solar']

        # Solar irradiance model (simplified)
        hour_of_day = weather_df['timestamp'].dt.hour
        daylight = np.where(
            (hour_of_day >= 6) & (hour_of_day <= 18),
            np.sin((hour_of_day - 6) * np.pi / 12),
            0
        )

        # Cloud cover reduction
        cloud_factor = 1 - 0.75 * weather_df['cloud_cover'].values

        # Temperature derating
        temp_factor = 1 - cfg['temp_coefficient'] * (weather_df['temperature'].values - 25)

        # Combined solar output
        solar_output = cfg['efficiency'] * daylight * cloud_factor * temp_factor
        solar_output = np.clip(solar_output, 0, 1)

        return solar_output

    def weather_to_wind_output(self, weather_df: pd.DataFrame) -> np.ndarray:
        """Convert weather data to wind power output (p.u.)"""
        cfg = self.config['renewables']['wind']

        v = weather_df['wind_speed'].values
        v_in = cfg['cut_in_speed']
        v_rated = cfg['rated_speed']
        v_out = cfg['cut_out_speed']

        # Wind power curve
        wind_output = np.zeros_like(v)

        # Region 2: Partial power
        mask_partial = (v >= v_in) & (v < v_rated)
        wind_output[mask_partial] = ((v[mask_partial]**3 - v_in**3) / 
                                      (v_rated**3 - v_in**3))

        # Region 3: Rated power
        mask_rated = (v >= v_rated) & (v < v_out)
        wind_output[mask_rated] = 1.0

        # Add turbulence
        wind_output += np.random.randn(len(wind_output)) * 0.05
        wind_output = np.clip(wind_output, 0, 1)

        return wind_output

    def get_renewable_forecast(self) -> Dict[str, np.ndarray]:
        """Get complete renewable generation forecast"""
        weather_df = self.fetch_forecast()

        return {
            'timestamps': weather_df['timestamp'].values,
            'solar_output': self.weather_to_solar_output(weather_df),
            'wind_output': self.weather_to_wind_output(weather_df),
            'weather_raw': weather_df
        }


if __name__ == "__main__":
    # Test the weather injector
    injector = WeatherInjector()
    forecast = injector.get_renewable_forecast()

    print("\n=== Renewable Energy Forecast ===")
    print(f"Forecast horizon: {len(forecast['timestamps'])} periods")
    print(f"Solar output range: {forecast['solar_output'].min():.2f} - {forecast['solar_output'].max():.2f} p.u.")
    print(f"Wind output range: {forecast['wind_output'].min():.2f} - {forecast['wind_output'].max():.2f} p.u.")
    print(f"\nFirst 3 periods:")
    print(forecast['weather_raw'].head(3))


Explain